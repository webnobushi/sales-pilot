次にやること

・メッセージの手動保存api実装
→文脈管理を永続化し、画面初期ロード時にそれを取得する。

・ワークフローでの手動ストリーミングおよびUI構築用メタデータ作成
→例：一覧データを取得しテーブルコンポーネントで表示する

・文脈管理のブラッシュアップ
→ワークフローに渡す前提でワークフローごとに必要な項目をスキーマ定義する
→理想的にはバリデーションフェーズを通してしまう。


実現したいこと

・writerの使い道を判明させる
→これはあくまでも一時的に表示するためだけのデータとする。
→進捗をいい感じに表示する方法はまだ思いつかない。
→大きな単位の処理の合間に出すのはまあ簡単だけれども。
→ワークフローのステップ進捗
→あとはツールの呼び出しとかかな。

ボツ
→文脈管理エージェントの分析結果を出せば面白いかもしれないけど、、
→途中の表示に使うのは厳しいか、、すでにレスポンス配信した後だから無理か、、

・通常会話の文脈を維持しつつワークフローへの移行をAIから提案しスムーズに移行する。
→できそうなことがわかった。

・レスポンスの定義でUIを動的に選択して応答する。
→これ結局一筋縄ではいかなそう
→HITLと同じようにmetadataでやるのが良さそう。
→そもそもこれはワークフローの処理になるはずだから、手動でレスポンス生成＆データ保存時にmetadataを設定すればいけるはず。

・v5でのHITLのresumeデータ管理方法を把握する。
→metadataを使う方法せいで考え中。

確認したいこと
・エージェントをフロントに立たせる方法がなぜ遅いのかもう一度検証する

→レスポンスの型を指定したり、ワークフローの応答をそのまま応答させる指示を入れたりで解決できないか？？
→確かDBの一覧データの応答でものすごく遅くなった。ツール経由だったかも。ツールの実行はすぐ終わるのにその後のレスポンスが異常に遅い事象。
→あとレスポンスがいうことを聞いてくれない問題もあった。これは多分outputの指定で解決できるはず。
→速度の問題よりエージェントの最終レスポンスを制御しきれない問題の方が大きい気がする。outputではダメだった。
→てかワークフローはユーザの指定があって初めて実行されると想定するとそれまではエージェントが自由に好き勝手に返しても良いのか？
→ただしその間に文脈をmetadataに溜め込んでおく必要はある。文脈が溜まったかどうかの判定結果はフロントエージェントが常に監視して、条件が揃ったらUI選択肢のメタデータを返却してそこからワークフローに持ち込むルートを作る。
→その選択肢を選択するとワークフローと関連するメタデータを合わせて送信することでワークフローが進むことになる。
→ただしワークフローの中で自然な会話をしたいケースがある（実行に必要な情報をstep by step で入力させる場合など）
→resume/suspendで実現する。
→よって元の設計からの変更で言うとエージェントをフロントに持って行ってもいいけど、文脈管理を追加で行い、ワークフローの開始はあくまでもユーザに委ねる形にする。（これまではワークフローの開始が自動だったのをHITLっぽくするイメージ）

後まだ不明確なのが、フロントエージェントがワークフローを実行するとき、レスポンスはワークフローの実行結果がそのまま返されるの？？
というかwriterを使ってワークフローのstreamから直接返した場合、エージェントにmemoryを渡しておけばメッセージの保存は自動でされることになる？？
うーん、ただしエージェントにワークフローを実行させると言うことはllmを実行することになるので遅くなる。
→やっぱりワークフローで手動でメッセージ保存が良さそう。
→基本的には現行踏襲な感じだけど、全ワークフローの文脈管理して、ワークフローの実行トリガーはユーザになるところがこれまでと大きな違い。
→麻雀みたいに役が揃ったら上がるかどうか選択肢の候補として挙げる感じ。
→関係あるデータはとりあえず保存しておき、ワークフロー選択時に関係データを一緒にこめることでやり取りが少なくなる。

→文脈管理の専用エージェントを作ってユーザへのレスポンスとは別で非同期で処理を行う（通常メッセージの応答速度を落とさないため）
→専用のdata type でレスポンスを行う。また、常に更新するために同じメッセージIDを使って更新を行う。
→別でレスポンスしたらフロント側でそのdata typeを見て選択肢を構築する。
→提案メッセージを選択肢に込める？「ECサイト構築のプロジェクト計画を行う」
→選択肢のラベルもLLMで生成する。

→文脈データは別のメモリに手動保存するようにする。
→エージェントの自動保存に任せると全てtextとして保存されるため。
→そうしないとwriterのデータ構造と異なってしまうのでフロントの制御を統一できない。